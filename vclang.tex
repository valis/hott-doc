\documentclass{amsart}

\usepackage{etex}
\usepackage[english,russian]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amssymb}
\usepackage[all]{xy}
\usepackage{verbatim}
\usepackage{ifthen}
\usepackage{xargs}
\usepackage{bussproofs}
\usepackage{type1ec}
\usepackage{stmaryrd}
\usepackage{tikz}
\usepackage{tikz-qtree}

\providecommand\WarningsAreErrors{false}
\ifthenelse{\equal{\WarningsAreErrors}{true}}{\renewcommand{\GenericWarning}[2]{\GenericError{#1}{#2}{}{This warning has been turned into a fatal error.}}}{}

\newcommand{\newref}[4][]{
\ifthenelse{\equal{#1}{}}{\newtheorem{h#2}[hthm]{#4}}{\newtheorem{h#2}{#4}[#1]}
\expandafter\newcommand\csname r#2\endcsname[1]{\ref{#2:##1}}
\expandafter\newcommand\csname R#2\endcsname[1]{#4~\ref{#2:##1}}
\newenvironmentx{#2}[2][1=,2=]{
\ifthenelse{\equal{##2}{}}{\begin{h#2}}{\begin{h#2}[##2]}
\ifthenelse{\equal{##1}{}}{}{\label{#2:##1}}
}{\end{h#2}}
}

\newref[section]{thm}{теорема}{Теорема}
\newref{lem}{лемма}{Лемма}
\newref{prop}{утверждение}{Утверждение}
\newref{cor}{следствие}{Следствие}

\theoremstyle{definition}
\newref{defn}{definition}{Definition}
\newref{example}{example}{Example}

\theoremstyle{remark}
\newref{remark}{замечание}{Замечание}

\newcommand{\red}{\Rightarrow}
\newcommand{\deq}{\Leftrightarrow}
\renewcommand{\ll}{\llbracket}
\newcommand{\rr}{\rrbracket}
\newcommand{\cat}[1]{\mathbf{#1}}
\renewcommand{\C}{\cat{C}}
\newcommand{\Set}{\cat{Set}}
\newcommand{\ccat}{\cat{CCat}}

\numberwithin{figure}{section}

\newcommand{\pb}[1][dr]{\save*!/#1-1.2pc/#1:(-1,1)@^{|-}\restore}
\newcommand{\po}[1][dr]{\save*!/#1+1.2pc/#1:(1,-1)@^{|-}\restore}

\begin{document}

\title{Vclang}

\author{Валерий Исаев}

% \begin{abstract}
% Abstract
% \end{abstract}

\maketitle

\section{Vccore}

Язык vclang состоит из двух частей: ядра (vccore) и фронтенд (vclang).
Пользователь пишет код на vclang, и он транслируется в vccore.
Как это происходит мы обсудим позже, в этом разделе мы опишем ядро.

Программа на vccore состоит из множества объявлений (то есть \emph{неупорядоченного} списка).
Каждое объявление состоит из уникального имени и \emph{определения}, которые бывают трех видов:
\begin{itemize}
\item \emph{Функция} содержит сигнатуру, которая является типом, и тело, которое является выражением. Типы и выражения в vccore будут определены позже.
\item \emph{Алгебраический тип данных} содержит некоторый контекст, описывающий параметры типа данных, и список конструкторов, каждый из которых состоит из имени и контекста, описывающего параметры конструктора.
\item \emph{Класс} содержит список полей. Каждое поле состоит из уникального имени и сигнатуры.
\end{itemize}
Классы в vccore устроенны очень просто, по сути, они являются просто записями.
Классы не могут наследоваться друг от друга, но можно использовать анонимное наследование.
Если $A$ -- некоторый класс, содержащий поля $f_1, \ldots f_n$, то $A\ \{\ f_1 \mapsto d_1,\ \ldots\ f_n \mapsto d_n\ \}$ -- анонимный наследник класса $A$.
Здесь $d_i$ -- это определение либо функции, либо типа данных.

Если $A\ \{\ f_1 \mapsto d_1,\ \ldots\ f_n \mapsto d_n\ \}$ -- коректный тип и все поля $A$ присутствуют в списке $f_1, \ldots f_n$, то его элементы создаются при помощи конструкции $\mathbf{new}$:
\[ \mathbf{new}\ A\ \{\ f_1 \mapsto d_1,\ \ldots\ f_n \mapsto d_n\ \} : A\ \{\ f_1 \mapsto d_1,\ \ldots\ f_n \mapsto d_n\ \} \]

\subsection{Формальное определение термов vccore}

Как обычно, мы сначала опишем множество сырых термов, после чего определим отношения типизации.
Выражения и типы vccore тогда будут определятся как типизируемые термы.

Множество термов

\section{Vclang}



\bibliographystyle{amsplain}
\bibliography{ref}

\end{document}
